                                            Dependency: Validation
________________________________________________________________________________________________________________________
The spring-boot-starter-validation is a starter dependency that simplifies input validation in Spring Boot applications 
by automatically bringing in the necessary libraries, primarily the Hibernate Validator (the reference implementation of 
the Jakarta Bean Validation specification).

https://docs.spring.io/spring-framework/docs/4.1.x/spring-framework-reference/html/validation.html#validation-beanvalidation
________________________________________________________________________________________________________________________
                                            Classes/Interfaces Discovered
________________________________________________________________________________________________________________________
WebMvcConfigurer - Defines callback methods to customize the Java-based configuration for Spring MVC enabled via 
	@EnableWebMvc. (interface)

ViewControllerRegistry - Assists with the registration of simple automated controllers pre-configured with status code 
	and/or a view. 

BindingResult - General interface that represents binding results. Extends the Errors interface for error registration 
	capabilities, allowing for a Validator to be applied, and adds binding-specific analysis and model building.
	Serves as result holder for a DataBinder, obtained via the DataBinder.getBindingResult() method. BindingResult 
	implementations can also be used directly, for example to invoke a Validator on it (for example, as part of a unit 
	test). (interface)

https://docs.spring.io/spring-framework/docs/current/javadoc-api/index.html
________________________________________________________________________________________________________________________
                                            Annotations Discovered
________________________________________________________________________________________________________________________
@Valid - The @Valid annotation is part of the standard JSR-303 Bean Validation API, and is not a Spring-specific construct.
	Spring MVC will validate a @Valid object after binding so-long as an appropriate Validator has been configured.

	See reference for spring-boot-starter-validation in -> Dependency: Validation


@ModelAttribute - Annotation that binds a method parameter or method return value to a named model attribute, exposed to a 
	web view. Supported for controller classes with @RequestMapping methods.

	WARNING: Data binding can lead to security issues by exposing parts of the object graph that are not meant to be accessed
	or modified by external clients. Therefore the design and use of data binding should be considered carefully with regard 
	to security. For more details, please refer to the dedicated sections on data binding for Spring Web MVC and Spring 
	WebFlux in the reference manual.


@EnableWebMvc-annotated configuration classes may implement this interface to be called back and given a chance to 
	customize the default configuration. 

https://docs.spring.io/spring-framework/docs/current/javadoc-api/index.html
________________________________________________________________________________________________________________________
                                            Technical Roadblocks
________________________________________________________________________________________________________________________
Unresolved Thymeleaf references in form.html:
To resolve, @ModelAttribute needed to be added to each object reference to ensure that the object being referenced in the
	html is added to the spring model object in the controller method.
________________________________________________________________________________________________________________________
                                            Layered Architecture
________________________________________________________________________________________________________________________
Layered Architecture Structure
Key Principles
	• DTOs in Presentation Layer - Never expose entities directly to clients
	• Entities in Persistence Layer - Domain models with JPA annotations
	• Business Logic in Service Layer - Never in controllers or repositories
	• Security is Cross-cutting - But configuration lives in security package
	• Dependencies flow downward - Controller → Service → Repository (never upward)
1. Presentation Layer (Web/API Layer)
Purpose: Handles HTTP requests/responses, user input, and data presentation
Folders:
	• controller/ - REST controllers, MVC controllers
	• dto/ or request/ and response/ - Data Transfer Objects for API/form input and output
	• mapper/ - Converts between DTOs and domain entities
	• validator/ - Custom validation logic
	• config/web/ - Web-specific configuration (CORS, interceptors)
Spring Boot Example Classes:
	• UserController.java
	• LoginRequest.java, RegisterRequest.java
	• UserResponse.java
	• UserDtoMapper.java

2. Service Layer (Business Logic Layer)
Purpose: Contains core business logic, orchestrates operations, enforces business rules
Folders:
	• service/ - Business logic interfaces and implementations
	• exception/ - Custom business exceptions
Spring Boot Example Classes:
	• UserService.java, UserServiceImpl.java
	• AuthenticationService.java
	• OrderProcessingService.java
	• UserNotFoundException.java

3. Persistence Layer (Data Access Layer)
Purpose: Handles database operations and data persistence
Folders:
	• repository/ - Spring Data JPA repositories
	• entity/ or model/ or domain/ - JPA entities (domain models)
	• specification/ - JPA Specifications for complex queries (optional)
Spring Boot Example Classes:
	• UserRepository.java (extends JpaRepository)
	• User.java (JPA entity with @Entity)
	• Role.java, Order.java

4. Security Layer (Cross-cutting, but often separate)
Purpose: Authentication, authorization, and security configuration
Folders:
	• security/ or config/security/ - Security configuration
	• security/jwt/ - JWT utilities
	• security/filter/ - Custom filters
Spring Security Example Classes:
	• SecurityConfig.java (WebSecurityConfigurerAdapter)
	• JwtTokenProvider.java
	• JwtAuthenticationFilter.java
	• CustomUserDetailsService.java

5. Infrastructure/Configuration Layer (Cross-cutting)
Purpose: Application configuration, external integrations, utilities
Folders:
	• config/ - Application configuration classes
	• util/ or helper/ - Utility classes
	• client/ - External API clients
	• messaging/ - Message queue handlers
Spring Boot Example Classes:
	• DatabaseConfig.java
	• RedisConfig.java
	• DateUtil.java
	• EmailClient.java

Practical Spring Boot/Spring Security Example
src/main/java/com/example/ecommerce/
│
├── presentation/
│   ├── controller/
│   │   ├── AuthController.java
│   │   ├── UserController.java
│   │   └── OrderController.java
│   ├── dto/
│   │   ├── request/
│   │   │   ├── LoginRequest.java
│   │   │   ├── RegisterRequest.java
│   │   │   └── CreateOrderRequest.java
│   │   └── response/
│   │       ├── AuthResponse.java
│   │       ├── UserResponse.java
│   │       └── OrderResponse.java
│   └── mapper/
│       ├── UserMapper.java
│       └── OrderMapper.java
│
├── service/
│   ├── AuthenticationService.java
│   ├── UserService.java
│   ├── UserServiceImpl.java
│   ├── OrderService.java
│   └── exception/
│       ├── UserNotFoundException.java
│       ├── InvalidCredentialsException.java
│       └── InsufficientStockException.java
│
├── repository/
│   ├── UserRepository.java
│   ├── RoleRepository.java
│   └── OrderRepository.java
│
├── entity/
│   ├── User.java
│   ├── Role.java
│   ├── Order.java
│   └── OrderItem.java
│
├── security/
│   ├── SecurityConfig.java
│   ├── CustomUserDetailsService.java
│   ├── jwt/
│   │   ├── JwtTokenProvider.java
│   │   └── JwtAuthenticationFilter.java
│   └── AuthenticationEntryPoint.java
│
└── config/
    ├── DatabaseConfig.java
    └── CorsConfig.java

Data Flow Example: User Registration
	1. Presentation Layer: AuthController receives RegisterRequest DTO
	2. Presentation Layer: UserMapper converts DTO → User entity
	3. Service Layer: UserService.registerUser() validates business rules (email unique, password strength)
	4. Service Layer: Encodes password, assigns default role
	5. Persistence Layer: UserRepository.save() persists to database
	6. Service Layer: Returns User entity
	7. Presentation Layer: UserMapper converts User → UserResponse DTO
	8. Presentation Layer: AuthController returns HTTP 201 with UserResponse

________________________________________________________________________________________________________________________


